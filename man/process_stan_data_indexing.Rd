% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{process_stan_data_indexing}
\alias{process_stan_data_indexing}
\title{Process Stan Data Indexing}
\usage{
process_stan_data_indexing(SubjectID_orig_R, SampleID_orig_R, y_R)
}
\arguments{
\item{SubjectID_orig_R}{Character vector of
subject identifiers, one per observation.}

\item{SampleID_orig_R}{Integer vector of
within-subject sample numbers (1-based).
Must be positive integers.}

\item{y_R}{Numeric vector of response values.
Passed through unchanged; must be the same
length as the other inputs.}
}
\value{
A named \code{list} with elements:
\describe{
  \item{N_obs}{Integer. Total number of
    observations.}
  \item{y}{Numeric vector. Response variable
    (unchanged from input).}
  \item{N_subj}{Integer. Number of unique
    subjects.}
  \item{subj_idx}{Integer vector. 1-based
    subject index for each observation.}
  \item{N_samp_total}{Integer. Total number
    of samples across all subjects.}
  \item{samp_idx}{Integer vector. Global
    1-based sample index for each
    observation.}
  \item{sample_to_subj_map}{Integer vector.
    Maps each global sample index to its
    1-based subject index.}
}
}
\description{
Converts subject and sample
  identifiers into the integer index arrays
  required by hierarchical Stan models.
}
\details{
All three input vectors must have the same
length. The function:
\itemize{
  \item Maps character subject IDs to
    consecutive integers (1 to N_subj).
  \item Determines the maximum sample number
    per subject.
  \item Builds a global sample index using
    cumulative offsets.
  \item Creates a reverse map from global
    sample indices back to subjects.
}
}
\examples{
\dontrun{
subj <- c("A", "A", "B", "B", "B", "C")
samp <- c(1L, 2L, 1L, 2L, 3L, 1L)
y    <- c(1.2, 1.5, 2.1, 2.3, 2.0, 0.8)

result <- process_stan_data_indexing(
  subj, samp, y
)
str(result)
}

}
