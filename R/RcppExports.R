# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate CVs from Log-Transformed Posterior Draws (C++)
#'
#' Vectorised C++ implementation of the log-scale CV transforms applied to
#' every posterior draw.  Replaces R-level \code{apply()} loops.
#'
#' @param fit A named list of posterior draws containing elements
#'   \code{beta}, \code{sigma_I}, \code{sigma_I_sd}, \code{sigma_A},
#'   \code{sigma_G}, \code{sigma_I_pred}, \code{df_I}, \code{df_A},
#'   \code{sigma_i} (matrix), and \code{G} (matrix).
#'
#' @return A named list with elements: \code{beta_pred}, \code{cv_I},
#'   \code{cv_I_sd}, \code{cv_A}, \code{cv_G}, \code{cv_I_pred},
#'   \code{sd_I_pred}, \code{cv_pi} (matrix), \code{mu_pi} (matrix).
#'
#' @keywords internal
calculate_cvs_log_scale <- function(fit) {
    .Call(`_EstimatingBiologicalVariation_calculate_cvs_log_scale`, fit)
}

#' Calculate CVs from Identity-Scale Posterior Draws (C++)
#'
#' Vectorised C++ implementation of the identity-scale CV transforms.
#' Truncated-normal draws for the predictive mean of a new subject are
#' generated internally via \code{truncnorm::rtruncnorm}.
#'
#' @param fit A named list of posterior draws containing elements
#'   \code{beta}, \code{sigma_I}, \code{sigma_I_sd}, \code{sigma_A},
#'   \code{sigma_G}, \code{sigma_I_pred}, \code{df_I}, \code{df_A},
#'   \code{sigma_i} (matrix), and \code{G} (matrix).
#'
#' @return A named list with elements: \code{beta_pred}, \code{cv_I},
#'   \code{cv_I_sd}, \code{cv_A}, \code{cv_G}, \code{cv_I_pred},
#'   \code{sd_I_pred}, \code{cv_pi} (matrix), \code{mu_pi} (matrix).
#'
#' @keywords internal
calculate_cvs_identity_scale <- function(fit) {
    .Call(`_EstimatingBiologicalVariation_calculate_cvs_identity_scale`, fit)
}

#' Column-wise log-t scale to CV (C++)
#'
#' Replaces \code{apply(mat, 2, function(x) logt_scale_to_cv(x, df))}.
#' Each element \code{(i,j)} of the result is
#' \code{sqrt(exp(mat[i,j]^2 * df[i] / (df[i]-2)) - 1) * 100}.
#'
#' @param mat  Numeric matrix (draws x subjects).
#' @param df   Numeric vector of length \code{nrow(mat)}.
#' @return A numeric matrix of the same dimensions as \code{mat}.
#' @keywords internal
apply_logt_scale_to_cv <- function(mat, df) {
    .Call(`_EstimatingBiologicalVariation_apply_logt_scale_to_cv`, mat, df)
}

#' Column-wise exp(x + offset) (C++)
#'
#' Replaces \code{apply(mat, 2, function(x) exp(x + offset))}.
#' Each element \code{(i,j)} of the result is
#' \code{exp(mat[i,j] + offset[i])}.
#'
#' @param mat     Numeric matrix (draws x subjects).
#' @param offset  Numeric vector of length \code{nrow(mat)}.
#' @return A numeric matrix of the same dimensions as \code{mat}.
#' @keywords internal
apply_exp_offset <- function(mat, offset) {
    .Call(`_EstimatingBiologicalVariation_apply_exp_offset`, mat, offset)
}

#' Column-wise addition of an offset vector (C++)
#'
#' Replaces \code{apply(mat, 2, function(x) x + offset)}.
#' Each element \code{(i,j)} of the result is
#' \code{mat[i,j] + offset[i]}.
#'
#' @param mat     Numeric matrix (draws x subjects).
#' @param offset  Numeric vector of length \code{nrow(mat)}.
#' @return A numeric matrix of the same dimensions as \code{mat}.
#' @keywords internal
apply_add_offset <- function(mat, offset) {
    .Call(`_EstimatingBiologicalVariation_apply_add_offset`, mat, offset)
}

#' Column-wise Student-t scale to SD (C++)
#'
#' Replaces \code{apply(mat, 2, function(x) t_scale_to_sd(x, df))}.
#' Each element \code{(i,j)} of the result is
#' \code{mat[i,j] * sqrt(df[i] / (df[i] - 2))}.
#'
#' @param mat  Numeric matrix (draws x subjects).
#' @param df   Numeric vector of length \code{nrow(mat)}.
#' @return A numeric matrix of the same dimensions as \code{mat}.
#' @keywords internal
apply_t_scale_to_sd <- function(mat, df) {
    .Call(`_EstimatingBiologicalVariation_apply_t_scale_to_sd`, mat, df)
}

#' @title Process Stan Data Indexing
#'
#' @description Converts subject and sample
#'   identifiers into the integer index arrays
#'   required by hierarchical Stan models.
#'
#' @param SubjectID_orig_R Character vector of
#'   subject identifiers, one per observation.
#' @param SampleID_orig_R Integer vector of
#'   within-subject sample numbers (1-based).
#'   Must be positive integers.
#' @param y_R Numeric vector of response values.
#'   Passed through unchanged; must be the same
#'   length as the other inputs.
#'
#' @return A named \code{list} with elements:
#' \describe{
#'   \item{N_obs}{Integer. Total number of
#'     observations.}
#'   \item{y}{Numeric vector. Response variable
#'     (unchanged from input).}
#'   \item{N_subj}{Integer. Number of unique
#'     subjects.}
#'   \item{subj_idx}{Integer vector. 1-based
#'     subject index for each observation.}
#'   \item{N_samp_total}{Integer. Total number
#'     of samples across all subjects.}
#'   \item{samp_idx}{Integer vector. Global
#'     1-based sample index for each
#'     observation.}
#'   \item{sample_to_subj_map}{Integer vector.
#'     Maps each global sample index to its
#'     1-based subject index.}
#' }
#'
#' @details
#' All three input vectors must have the same
#' length. The function:
#' \itemize{
#'   \item Maps character subject IDs to
#'     consecutive integers (1 to N_subj).
#'   \item Determines the maximum sample number
#'     per subject.
#'   \item Builds a global sample index using
#'     cumulative offsets.
#'   \item Creates a reverse map from global
#'     sample indices back to subjects.
#' }
#'
#' @examples
#' \dontrun{
#' subj <- c("A", "A", "B", "B", "B", "C")
#' samp <- c(1L, 2L, 1L, 2L, 3L, 1L)
#' y    <- c(1.2, 1.5, 2.1, 2.3, 2.0, 0.8)
#'
#' result <- process_stan_data_indexing(
#'   subj, samp, y
#' )
#' str(result)
#' }
#'
#' @export
process_stan_data_indexing <- function(SubjectID_orig_R, SampleID_orig_R, y_R) {
    .Call(`_EstimatingBiologicalVariation_process_stan_data_indexing`, SubjectID_orig_R, SampleID_orig_R, y_R)
}

#' @title Generate Stan Data List for Priors
#'
#' @name process_stan_data_priors
#'
#' @param beta A \code{double} representing the expected
#'   value of the main parameter.
#' @param cvi Expected CV for individual-level variance
#'   (I), as a percentage (e.g., 10 for 10\%). Must be
#'   strictly positive. Defaults to 10.
#' @param cva Expected CV for assay-level variance (A),
#'   as a percentage. Must be strictly positive.
#'   Defaults to 3.
#' @param cvg Expected CV for group-level variance (G),
#'   as a percentage. Must be strictly positive.
#'   Defaults to 20.
#' @param dfi Expected degrees of freedom for the
#'   individual-level t-distribution. Must be >= 2.1.
#'   Defaults to 9999.
#' @param dfa Expected degrees of freedom for the
#'   assay-level t-distribution. Must be >= 2.1.
#'   Defaults to 9999.
#' @param hbhr Expected Harris-Brown heterogeneity
#'   ratio, as a percentage. Must be > 0.
#'   Defaults to 50.
#' @param strength A \code{NumericVector} of length 7
#'   with non-negative multipliers controlling the SD
#'   of each hyperprior. Elements map to:
#'   \enumerate{
#'     \item \code{beta}
#'     \item \code{sigma_I} (mean)
#'     \item \code{sigma_A}
#'     \item \code{sigma_G}
#'     \item \code{df_I}
#'     \item \code{df_A}
#'     \item \code{hbhr}
#'   }
#'   Defaults to \code{c(1, 1, 1, 1, 1, 1, 2/3)}.
#' @param log_transformed Logical; if \code{TRUE},
#'   priors for \code{sigma_I}, \code{sigma_A}, and
#'   \code{sigma_G} are computed on the log scale.
#'   Defaults to \code{FALSE}.
#'
#' @description
#' Converts user-friendly prior specifications into
#' hyperparameters (means and SDs) for a Stan model.
#'
#' @details
#' Takes an expected value (\code{beta}), coefficients
#' of variation, degrees of freedom, and a
#' heterogeneity ratio, then derives the location and
#' scale parameters for the Stan prior distributions.
#' The \code{strength} vector scales each prior SD
#' independently.
#'
#' @return A named \code{list} of Stan hyperparameters:
#' \describe{
#'   \item{\code{prior_beta_mean}}{
#'     Mean for the prior on \code{beta}.}
#'   \item{\code{prior_beta_sd}}{
#'     SD for the prior on \code{beta}.}
#'   \item{\code{prior_sigma_i_mean_mean}}{
#'     Mean of the hyperprior on E[\code{sigma_I}].}
#'   \item{\code{prior_sigma_i_mean_sd}}{
#'     SD of the hyperprior on E[\code{sigma_I}].}
#'   \item{\code{prior_sigma_i_sd_mean}}{
#'     Mean of the hyperprior on SD[\code{sigma_I}].}
#'   \item{\code{prior_sigma_i_sd_sd}}{
#'     SD of the hyperprior on SD[\code{sigma_I}].}
#'   \item{\code{prior_sigma_A_mean}}{
#'     Mean for the prior on \code{sigma_A}.}
#'   \item{\code{prior_sigma_A_sd}}{
#'     SD for the prior on \code{sigma_A}.}
#'   \item{\code{prior_sigma_G_mean}}{
#'     Mean for the prior on \code{sigma_G}.}
#'   \item{\code{prior_sigma_G_sd}}{
#'     SD for the prior on \code{sigma_G}.}
#'   \item{\code{prior_df_I_mean}}{
#'     Mean for the prior on \code{df_I}.}
#'   \item{\code{prior_df_I_sd}}{
#'     SD for the prior on \code{df_I}.}
#'   \item{\code{prior_df_A_mean}}{
#'     Mean for the prior on \code{df_A}.}
#'   \item{\code{prior_df_A_sd}}{
#'     SD for the prior on \code{df_A}.}
#' }
#'
#' @examples
#' # Default priors for beta = 100
#' process_stan_data_priors(beta = 100)
#'
#' # Log-transformed model with tighter CVs
#' process_stan_data_priors(
#'   beta = 7, cvi = 5, cva = 2,
#'   log_transformed = TRUE
#' )
#'
#' # Wider beta prior (strength[1] = 2)
#' process_stan_data_priors(
#'   beta = 100,
#'   strength = c(2, 1, 1, 1, 1, 1, 2/3)
#' )
#'
#' @export
process_stan_data_priors <- function(beta, cvi = 10.0, cva = 3.0, cvg = 20.0, dfi = 9999.0, dfa = 9999.0, hbhr = 50.0, strength = as.numeric( c(1, 1, 1, 1, 1, 1, 0.667)), log_transformed = FALSE) {
    .Call(`_EstimatingBiologicalVariation_process_stan_data_priors`, beta, cvi, cva, cvg, dfi, dfa, hbhr, strength, log_transformed)
}

#' Nested ANOVA for Biological Variation Data
#'
#' @name bv_anova
#'
#' @description
#' Fits one-way (per-subject) and two-way (overall) nested
#' random-effects ANOVA models to biological variation data.
#' Decomposes total variance into between-subject,
#' within-subject, and analytical (residual) components
#' using unweighted sums of squares.
#'
#' @param data A \code{list} (or \code{data.table}) with the
#'   following columns or elements, each of equal length:
#'   \describe{
#'     \item{\code{SubjectID}}{\code{integer} vector.
#'       Identifies the individual or participant.}
#'     \item{\code{SampleID}}{\code{integer} vector.
#'       Identifies the specimen collected from a subject.}
#'     \item{\code{ReplicateID}}{\code{integer} vector.
#'       Identifies the replicate measurement within a
#'       sample.}
#'     \item{\code{y}}{\code{numeric} vector. The measured
#'       analyte values.  \code{NA} values are silently
#'       excluded.}
#'   }
#' @param cv_anova \code{logical}.  When \code{TRUE}, each
#'   subject's measurements are divided by that subject's
#'   mean before fitting the ANOVA, yielding a CV-ANOVA
#'   whose variance components estimate coefficients of
#'   variation directly.  Default is \code{FALSE}.
#'
#' @details
#' The three-level nested random-effects model is:
#'
#' \deqn{y_{isr} = \mu + G_i + I_{is} + A_{isr}}
#'
#' where
#' \itemize{
#'   \item \eqn{G_i \sim N(0,\, \sigma_G^2)} is the
#'     between-subject effect,
#'   \item \eqn{I_{is} \sim N(0,\, \sigma_I^2)} is the
#'     within-subject (between-sample) effect, and
#'   \item \eqn{A_{isr} \sim N(0,\, \sigma_A^2)} is the
#'     analytical (residual / replicate) error.
#' }
#'
#' The function computes both weighted and unweighted sums
#' of squares and returns the weighting coefficients
#' \eqn{w_{1U}}, \eqn{w_{2U}}, and \eqn{w_{3U}} needed
#' to recover variance-component point estimates from the
#' unweighted mean squares.  It also provides per-subject
#' estimates of \eqn{\sigma_I} and \eqn{\sigma_A}, which
#' are used to compute the Heterogeneity of Biological
#' Homeostatic Ratio (HBHR).
#'
#' @return A named \code{list} with:
#'   \describe{
#'     \item{\code{beta}}{Grand mean (\eqn{\mu}).}
#'     \item{\code{S1U_squared}}{Unweighted mean square
#'       between subjects.}
#'     \item{\code{S2U_squared}}{Unweighted mean square
#'       between samples within subjects.}
#'     \item{\code{S3_squared}}{Mean square within samples
#'       (analytical / residual).}
#'     \item{\code{n1}}{Degrees of freedom: between
#'       subjects (\eqn{I - 1}).}
#'     \item{\code{n2}}{Degrees of freedom: between
#'       samples within subjects
#'       (\eqn{\sum_i J_i - I}).}
#'     \item{\code{n3}}{Degrees of freedom: within
#'       samples (\eqn{N - \sum_i J_i}).}
#'     \item{\code{w1U, w2U, w3U}}{Weighting coefficients
#'       for the unweighted sums of squares.}
#'     \item{\code{sigma_i}}{\code{numeric} vector of
#'       per-subject within-subject SD estimates.}
#'     \item{\code{sigma_a}}{\code{numeric} vector of
#'       per-subject analytical SD estimates.}
#'     \item{\code{HBHR}}{Harris-Brown Heterogeneity Ratio (\%).}
#'   }
#'
#' @seealso \code{\link{variance_components}} for
#'   extracting point estimates and confidence intervals;
#'   \code{\link{bv_anova_bootstrap_ci}} for bootstrap
#'   confidence intervals.
#'
#' @examples
#' \dontrun{
#' dat       <- simulate_bv_data(
#'   15, 10, 2, 10, 2, 50, 100
#' )
#' anova_fit <- bv_anova(dat)
#' anova_fit$beta        # grand mean
#' anova_fit$S3_squared  # analytical mean square
#' }
#'
#' @export
bv_anova <- function(data, cv_anova = FALSE) {
    .Call(`_EstimatingBiologicalVariation_bv_anova`, data, cv_anova)
}

#' Variance-Component Point Estimates and Confidence
#' Intervals
#'
#' @name variance_components
#'
#' @description
#' Extracts variance-component standard deviations
#' (or CVs) from a nested ANOVA fit, with optional
#' confidence intervals based on the generalised
#' inference approach of Burdick & Graybill (1992).
#'
#' @param data A \code{list} (or \code{data.frame})
#'   passed to \code{\link{bv_anova}}.  Must contain
#'   \code{SubjectID}, \code{SampleID},
#'   \code{ReplicateID}, and \code{y}.
#' @param output_type \code{character} string selecting
#'   the type of output.  One of:
#'   \describe{
#'     \item{\code{"sigma"}}{Point-estimate SDs.}
#'     \item{\code{"cv"}}{Point-estimate CVs
#'       (SDs divided by the grand mean).}
#'     \item{\code{"sigma_ci"}}{SDs with
#'       \eqn{(1-\alpha)} confidence intervals.}
#'     \item{\code{"cv_ci"}}{CVs with
#'       \eqn{(1-\alpha)} confidence intervals.}
#'   }
#'   Default is \code{"sigma"}.
#' @param mult \code{numeric} scaling factor applied to
#'   every estimate and CI bound.  For example, use
#'   \code{mult = 100} to express CVs as percentages.
#'   Default is \code{1}.
#' @param level \code{numeric} confidence level for CIs,
#'   between 0 and 1.  Ignored when \code{output_type}
#'   is \code{"sigma"} or \code{"cv"}.
#'   Default is \code{0.95}.
#' @param cv_anova \code{logical}.  When \code{TRUE},
#'   the underlying ANOVA is run on subject-mean-scaled
#'   values (CV-ANOVA).  Default is \code{FALSE}.
#'
#' @details
#' For \code{output_type = "sigma"} or \code{"cv"},
#' the function returns scalar point estimates of
#' \eqn{\sigma_A} (analytical), \eqn{\sigma_I}
#' (within-subject), and \eqn{\sigma_G}
#' (between-subject).
#'
#' For \code{output_type = "sigma_ci"} or
#' \code{"cv_ci"}, each component is a length-3
#' \code{numeric} vector
#' \code{[estimate, lower, upper]}.  The CI for
#' \eqn{\sigma_A} uses a chi-squared pivot; CIs for
#' \eqn{\sigma_I} and \eqn{\sigma_G} follow the
#' generalised confidence-interval method using
#' approximate F-distribution pivots (Burdick &
#' Graybill, 1992).
#'
#' Negative variance estimates are truncated to zero
#' before taking square roots.
#'
#' @return A named \code{list} with:
#'   \describe{
#'     \item{\code{sigma_A}}{Analytical SD (or CV).
#'       Scalar or length-3 vector depending on
#'       \code{output_type}.}
#'     \item{\code{sigma_I}}{Within-subject SD
#'       (or CV).  Same structure as above.}
#'     \item{\code{sigma_G}}{Between-subject SD
#'       (or CV).  Same structure as above.}
#'     \item{\code{sigma_i}}{\code{numeric} vector
#'       of per-subject within-subject SD (or CV)
#'       estimates.}
#'     \item{\code{sigma_a}}{\code{numeric} vector
#'       of per-subject analytical SD (or CV)
#'       estimates.}
#'     \item{\code{HBHR}}{Heterogeneity of Biological
#'       Homeostatic Ratio (\%).}
#'     \item{\code{beta}}{Grand mean
#'       (\eqn{\hat\mu}).}
#'   }
#'
#' @references
#' Burdick, R. K. and Graybill, F. A. (1992).
#' \emph{Confidence Intervals on Variance Components}.
#' Marcel Dekker, New York.
#'
#' @seealso \code{\link{bv_anova}} for the underlying
#'   ANOVA fit; \code{\link{bv_anova_bootstrap_ci}} for
#'   non-parametric bootstrap CIs.
#'
#' @examples
#' \dontrun{
#' dat <- simulate_bv_data(
#'   15, 10, 2, 10, 2, 50, 100
#' )
#' # Point-estimate SDs
#' variance_components(dat, "sigma")
#'
#' # CVs (%) with 95% CIs
#' variance_components(
#'   dat, "cv_ci", mult = 100, level = 0.95
#' )
#' }
#'
#' @export
variance_components <- function(data, output_type = "sigma", mult = 1.0, level = 0.95, cv_anova = FALSE) {
    .Call(`_EstimatingBiologicalVariation_variance_components`, data, output_type, mult, level, cv_anova)
}

#' Bootstrap Confidence Intervals for ANOVA
#' Variance Components
#'
#' @name bv_anova_bootstrap_ci
#'
#' @description
#' Estimates percentile bootstrap confidence intervals
#' for the variance-component standard deviations (or
#' CVs) obtained from \code{\link{variance_components}}.
#' Subjects are resampled with replacement; the sample
#' and replicate structure within each selected subject
#' is kept intact.
#'
#' @param data_orig A \code{list} (or \code{data.table})
#'   with the same structure required by
#'   \code{\link{bv_anova}}:
#'   \describe{
#'     \item{\code{SubjectID}}{\code{integer} vector
#'       of subject identifiers.}
#'     \item{\code{SampleID}}{\code{integer} vector
#'       of sample identifiers.}
#'     \item{\code{ReplicateID}}{\code{integer} vector
#'       of replicate identifiers.}
#'     \item{\code{y}}{\code{numeric} vector of
#'       measured values.}
#'   }
#' @param B \code{integer}.  Number of bootstrap
#'   replicates to draw.  Values of 1000--10 000 are
#'   typical.
#' @param level \code{numeric} confidence level,
#'   between 0 and 1.  Default is \code{0.95}.
#' @param output_type_for_point_est \code{character}.
#'   Either \code{"sigma"} (default) to report SDs
#'   or \code{"cv"} to report coefficients of
#'   variation.
#' @param mult \code{numeric} scaling factor applied
#'   to every estimate and CI bound (e.g. \code{100}
#'   for percentages).  Default is \code{1}.
#'
#' @details
#' At each bootstrap iteration the function:
#' \enumerate{
#'   \item Draws \eqn{I} subjects with replacement
#'     from the unique subject IDs (where \eqn{I} is
#'     the number of unique subjects in
#'     \code{data_orig}).
#'   \item Assembles the full sample-by-replicate
#'     data for the resampled subjects, remapping
#'     subject IDs to \eqn{1, \ldots, I}.
#'   \item Calls \code{\link{variance_components}} on
#'     the bootstrap dataset.
#' }
#'
#' Percentile CIs are taken as the \eqn{\alpha / 2}
#' and \eqn{1 - \alpha / 2} quantiles of the \eqn{B}
#' bootstrap estimates (using \code{type = 7}
#' quantile interpolation).  Iterations that fail or
#' produce \code{NA} are excluded from the quantile
#' calculation.
#'
#' @return A named \code{list} with two elements:
#'   \describe{
#'     \item{\code{point_estimates}}{A \code{list} of
#'       scalar point estimates from the original data:
#'       \code{sigma_A}, \code{sigma_I},
#'       \code{sigma_G}, \code{HBHR}, and
#'       \code{beta}.}
#'     \item{\code{conf_intervals}}{A \code{list} of
#'       length-2 \code{numeric} vectors
#'       \code{[lower, upper]} for each parameter:
#'       \code{sigma_A_CI}, \code{sigma_I_CI},
#'       \code{sigma_G_CI}, \code{HBHR_CI}, and
#'       \code{beta_CI}.}
#'   }
#'
#' @seealso \code{\link{variance_components}} for the
#'   parametric (Burdick--Graybill) CI approach;
#'   \code{\link{bv_anova}} for the underlying ANOVA.
#'
#' @examples
#' \dontrun{
#' dat <- simulate_bv_data(
#'   15, 10, 2, 10, 2, 50, 100
#' )
#' set.seed(42)
#' boot_ci <- bv_anova_bootstrap_ci(
#'   dat, B = 2000, level = 0.95,
#'   output_type_for_point_est = "cv",
#'   mult = 100
#' )
#' boot_ci$point_estimates$sigma_A
#' boot_ci$conf_intervals$sigma_A_CI
#' }
#'
#' @export
bv_anova_bootstrap_ci <- function(data_orig, B, level = 0.95, output_type_for_point_est = "sigma", mult = 1.0) {
    .Call(`_EstimatingBiologicalVariation_bv_anova_bootstrap_ci`, data_orig, B, level, output_type_for_point_est, mult)
}

